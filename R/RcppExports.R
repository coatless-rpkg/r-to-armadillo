# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Generate Random Wishart Distribution
#' @description Creates a random wishart distribution when given degrees of freedom and a sigma matrix. 
#' @param df An \code{int}, which gives the degrees of freedom of the Wishart.  (> 0)
#' @param S A \code{matrix} with dimensions m x m that provides Sigma, the covariance matrix. 
#' @return A \code{matrix} that is a Wishart distribution, aka the sample covariance matrix of a Multivariate Normal Distribution
#' @seealso \code{\link{riwishart}} 
#' @author James J Balamuta
#' @examples 
#' #Call with the following data:
#' rwishart(3, diag(2))
#' 
#' # Validation
#' set.seed(1337)
#' S = toeplitz((10:1)/10)
#' n = 10000
#' o = array(dim = c(10,10,n))
#' for(i in 1:n){
#' o[,,i] = rwishart(20, S)
#' }
#' mR = apply(o, 1:2, mean)
#' Va = 20*(S^2 + tcrossprod(diag(S)))
#' vR = apply(o, 1:2, var)
#' stopifnot(all.equal(vR, Va, tolerance = 1/16))
#' 
rwishart <- function(df, S) {
    .Call('_r2arma_rwishart', PACKAGE = 'r2arma', df, S)
}

#' @title Generate Random Inverse Wishart Distribution
#' @description Creates a random inverse wishart distribution when given degrees of freedom and a sigma matrix. 
#' @param df An \code{int} that represents the degrees of freedom.  (> 0)
#' @param S A \code{matrix} with dimensions m x m that provides Sigma, the covariance matrix. 
#' @return A \code{matrix} that is an inverse wishart distribution.
#' @seealso \code{\link{rwishart}}
#' @author James J Balamuta
#' @examples 
#' #Call with the following data:
#' riwishart(3, diag(2))
riwishart <- function(df, S) {
    .Call('_r2arma_riwishart', PACKAGE = 'r2arma', df, S)
}

#' Subset Non-connected Regions
#'
#' Replicates the subset functionality of a matrix in R.
#' @param x       A \code{matrix} of dimensions M x N
#' @param row_ind A \code{unsigned int vec} that contains the row indices within \eqn{[0,M-1]}.
#' @param col_ind A \code{unsigned int vec} that contains the column indices within \eqn{[0,N-1]}.
#' @return A \code{vec} with each element listed according to index specification.
#' @author JJB
#' @examples
#' # Generate a Matrix
#' m = matrix(1:12, nrow = 4)
#'
#' # Select Non-connect regions
#' row_index = c(1, 2, 1)
#' col_index = c(2, 2, 3)
#'
#' # Subset in R
#' m[cbind(row_index, col_index)]
#'
#' # Subset with Armadillo
#' get_elements(m, row_index - 1, col_index - 1)
get_elements <- function(x, row_ind, col_ind) {
    .Call('_r2arma_get_elements', PACKAGE = 'r2arma', x, row_ind, col_ind)
}

#' Reverse Subset Column
#'
#' Subsets the column by going from high indices to low (the reverse of the supported practice)
#' @param x     A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting column.
#' @param end   A \code{unsigned int} that indicates the ending column.
#' @return A \code{matrix} with matrix rows displayed in reverse order
#' @details Consider a vector x=[[1,2],[3,4]].
#' By setting \code{start=1} and \code{end=0}, the function would output x=[[2,1],[4,1]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix cols start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow = 2,byrow = TRUE)
#' rev_col_subset(x, 1, 0)
rev_col_subset <- function(x, start, end) {
    .Call('_r2arma_rev_col_subset', PACKAGE = 'r2arma', x, start, end)
}

#' Reverse Subset Row
#'
#' Subsets the row by going from high indices to low (the reverse of the supported practice)
#' @param x A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting row.
#' @param end A \code{unsigned int} that indicates the ending row.
#' @return x A \code{matrix} with matrix rows displayed in reversed order
#' @details Consider a vector x=[[1,2],[3,4]], the function would output x=[[3,4],[1,2]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix rows start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow=2,byrow=TRUE)
#' rev_row_subset(x, 1, 0)
rev_row_subset <- function(x, start, end) {
    .Call('_r2arma_rev_row_subset', PACKAGE = 'r2arma', x, start, end)
}

#' Reverse Armadillo Vector
#'
#' Reverses the order of an Armadillo Vector
#' @param x A \code{column vector} of length N
#' @return A \code{column vector} with its contents reversed.
#' @details Consider a vector x=[1,2,3,4,5], the function would output x=[5,4,3,2,1].
#' @author JJB
#' @examples
#' x = 1:5
#' reverse_vec(x)
reverse_vec <- function(x) {
    .Call('_r2arma_reverse_vec', PACKAGE = 'r2arma', x)
}

#' Transform an Armadillo field<vec> to a matrix
#'
#' Unlists vectors in a field and places them into a matrix
#' @param x A \code{field<vec>}.
#' @return A \code{mat} containing the field elements within a column.
#' @author JJB
field_to_matrix <- function(x) {
    .Call('_r2arma_field_to_matrix', PACKAGE = 'r2arma', x)
}

#' Accumulation of Armadillo field<vec>
#'
#' Sums vectors in a field into a single variable.
#' @param x A \code{field<vec>}.
#' @return An \code{mat} containing the field elements within a column.
#' @author JJB
sum_field_vec <- function(x) {
    .Call('_r2arma_sum_field_vec', PACKAGE = 'r2arma', x)
}

#' @title Generate an integer sequence of values
#' @description Creates a vector containing a sequence of values starting at the initial point and going to the terminal point.
#' @param a A \code{long int} that denotes the starting point.
#' @param b A \code{long int} that denotes the ending point.
#' @return A \code{vector} containing integer values from
#' @seealso \code{\link{rwishart}}
#' @author James J Balamuta
#' @backref src/seq.cpp
#' @backref inst/include/seq.h
#' @examples
#' # Call with the following data:
#' seq_int(3, 5)
#' seq_int(5, 3)
seq_int <- function(a, b) {
    .Call('_r2arma_seq_int', PACKAGE = 'r2arma', a, b)
}

#' @title Generate a sequence of values ranging from a to b given a fixed amount of points.
#' @description Creates a vector containing a sequence of values starting at the initial point and going to the terminal point.
#' @param from       A \code{long double} that denotes the starting point.
#' @param to         A \code{long double} indicating the end point.
#' @param length_out A \code{long unsigned int} that denotes the number of points to use.
#' @return A \code{vector} containing values moving from \eqn{[from,to]}.
#' @seealso \code{\link{seq}}
#' @author Anthony R. Colombo, James J Balamuta
#' @backref src/seq.cpp
#' @backref inst/include/seq.h
#' @examples
#' # Call with the following data:
#' seq_default(1, 2, 10)
#' seq_default(2, 1, 10)
seq_default <- function(from, to, length_out) {
    .Call('_r2arma_seq_default', PACKAGE = 'r2arma', from, to, length_out)
}

#' @title Generate a sequence of values ranging from -a to a given a fixed amount of points.
#' @description Creates a vector containing a sequence of values starting at the initial point and going to the terminal point.
#' @param a          A \code{long double} that denotes the starting point.
#' @param length_out A \code{long unsigned int} that denotes the number of points to use.
#' @return A \code{vector} of length \code{length_out} that contains values in \eqn{[-a,a]}.
#' @seealso \code{\link{seq}}
#' @author Anthony R. Colombo, James J Balamuta
#' @examples
#' # Call with the following data:
#' seq_default_a(1, 10)
#' seq_default_a(1, 10)
seq_default_a <- function(a, length_out) {
    .Call('_r2arma_seq_default_a', PACKAGE = 'r2arma', a, length_out)
}

#' @title Generate a sequence of values ranging from vector start to vector end
#' @description Creates a vector containing a sequence of values starting at the beginning and going to the end.
#' @param along_with A \code{vec} with length \eqn{n}.
#' @return A \code{vector} of length \eqn{n} that contains integer values in \eqn{[0, n - 1]}.
#' @seealso \code{\link{seq}}
#' @author James J Balamuta
#' @backref src/seq.cpp
#' @backref inst/include/seq.h
#' @examples
#' # Call with the following data:
#' seq_along_cpp(1:10)
#' seq_along_cpp(5:10)
seq_along_cpp <- function(along_with) {
    .Call('_r2arma_seq_along_cpp', PACKAGE = 'r2arma', along_with)
}

#' @title Generate a sequence of values ranging from 0 to n-1
#' @description Creates a vector containing a sequence of values starting at the initial point and going to the terminal point.
#' @param length_out An \code{long unsigned int} that denotes the number of points to use.
#' @return A \code{vector} of length \code{length_out} that contains integer values in \eqn{[0, length_out - 1]}.
#' @seealso \code{\link{seq}}
#' @author James J Balamuta
#' @backref src/seq.cpp
#' @backref inst/include/seq.h
#' @examples
#' # Call with the following data:
#' seq_len_cpp(2)
#' seq_len_cpp(4)
seq_len_cpp <- function(length_out) {
    .Call('_r2arma_seq_len_cpp', PACKAGE = 'r2arma', length_out)
}

#' @title Lagged Differences in Armadillo
#' @description Returns the ith difference of a time series of rth lag.
#' @param x A \code{vec} that is the time series
#' @param lag A \code{unsigned int} that indicates the lag
#' @param differences A \code{dif} that indicates how many differences should be taken
#' @return A \code{vector} containing the differenced time series.
#' @author JJB
#' @examples
#' x = rnorm(10000, 0, 1)
#' diff_cpp(x,1,1)
diff_cpp <- function(x, lag, differences) {
    .Call('_r2arma_diff_cpp', PACKAGE = 'r2arma', x, lag, differences)
}

#' @title Converting an ARMA Process to an Infinite MA Process
#' @description Takes an ARMA function and converts it to an infinite MA process.
#' @param ar A \code{column vector} of length p
#' @param ma A \code{column vector} of length q
#' @param lag_max A \code{int} of the largest MA(Inf) coefficient required.
#' @return A \code{column vector} containing coefficients
#' @details This function is a port of the base stats package's ARMAtoMA. There is no significant speed difference between the two.
#' @author R Core Team and JJB
#' @examples
#' # ARMA(2,1)
#' ARMAtoMA_cpp(c(1.0, -0.25), 1.0, 10)
#' # ARMA(0,1)
#' ARMAtoMA_cpp(numeric(0), 1.0, 10)
ARMAtoMA_cpp <- function(ar, ma, lag_max) {
    .Call('_r2arma_ARMAtoMA_cpp', PACKAGE = 'r2arma', ar, ma, lag_max)
}

#' @title Time Series Convolution Filters
#' @description Applies a convolution filter to a univariate time series.
#' @param x A \code{column vector} of length T
#' @param filter A \code{column vector} of length f
#' @param sides An \code{int} that takes either 1:for using past values only or 2: filter coefficients are centered around lag 0.
#' @param circular A \code{bool} that indicates if the filter should be wrapped around the ends of the time series.
#' @return A \code{column vec} that contains the results of the filtering process.
#' @details This is a port of the cfilter function harnessed by the filter function in stats. 
#' It is about 5-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' x = 1:100
#' # 
#' cfilter(x, rep(1, 3), sides = 2, circular = FALSE)
#' # Using R's function
#' filter(x, rep(1, 3))
#' #
#' cfilter(x, rep(1, 3), sides = 1, circular = FALSE)
#' # Using R's function
#' filter(x, rep(1, 3), sides = 1)
#' #
#' cfilter(x, rep(1, 3), sides = 1, circular = TRUE)
#' # Using R's function
#' filter(x, rep(1, 3), sides = 1, circular = TRUE)
cfilter <- function(x, filter, sides, circular) {
    .Call('_r2arma_cfilter', PACKAGE = 'r2arma', x, filter, sides, circular)
}

#' @title Time Series Recursive Filters
#' @description Applies a recursive filter to a univariate time series.
#' @usage rfilter(x, filter, init)
#' @param x A \code{column vector} of length T
#' @param filter A \code{column vector} of length f
#' @param init A \code{column vector} of length f that contains the initial values of the time series in reverse.
#' @return x A \code{column vector} with its contents reversed.
#' @details Note: The length of 'init' must be equal to the length of 'filter'.
#' This is a port of the rfilter function harnessed by the filter function in stats. 
#' It is about 6-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' x = 1:100
#' # 
#' rfilter(x, rep(1, 3), rep(1, 3))
#' # Using R's function
#' filter(x, rep(1, 3), method="recursive", init=rep(1, 3))
rfilter <- function(x, filter, init) {
    .Call('_r2arma_rfilter', PACKAGE = 'r2arma', x, filter, init)
}

#' @title Compute Theoretical ACF for an ARMA Process
#' @description Compute the theoretical autocorrelation function for an ARMA process.
#' @usage ARMAacf_cpp(ar,ma,lag_max)
#' @param ar A \code{vector} of length p containing AR coefficients
#' @param ma A \code{vector} of length q containing MA coefficients
#' @param lag_max A \code{unsigned integer} indicating the maximum lag necessary
#' @return x A \code{matrix} listing values from 1...nx in one column and 1...1, 2...2,....,n...n, in the other
#' @details This is an implementaiton of the ARMAacf function in R. It is approximately 40x times faster. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' # ARMA(2,1)
#' ARMAacf_cpp(c(1.0, -0.25), 1.0, lag_max = 10)
#' # ARMA(0,1)
#' ARMAacf_cpp(numeric(0), .35, lag_max = 10)
ARMAacf_cpp <- function(ar, ma, lag_max) {
    .Call('_r2arma_ARMAacf_cpp', PACKAGE = 'r2arma', ar, ma, lag_max)
}

#' @title Discrete Fourier Transformation for Autocovariance Function
#' @description Calculates the autovariance function (ACF) using Discrete Fourier Transformation.
#' @param x A \code{cx_vec}. 
#' @return A \code{vec} containing the ACF.
#' @details 
#' This implementation is 2x as slow as Rs. 
#' Two issues: 1. memory resize and 2. unoptimized fft algorithm in arma.
#' Consider piping back into R and rewrapping the object. (Decrease of about 10 microseconds.)
#' @examples
#' x=rnorm(100)
#' dft_acf(x)
dft_acf <- function(x) {
    .Call('_r2arma_dft_acf', PACKAGE = 'r2arma', x)
}

